package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/strfmt"
	"github.com/go-swagger/go-swagger/swag"
)

/*Refund Refund

swagger:model Refund
*/
type Refund struct {

	/* Account account
	 */
	Account *string `json:"account,omitempty"`

	/* { "description" : "Identifier of account to refund.", "verbs":["GET"] }
	 */
	AccountID *string `json:"accountID,omitempty"`

	/* { "description" : "Refunded amount", "verbs":[] }

	Required: true
	*/
	ActualRefundedValue float64 `json:"actualRefundedValue,omitempty"`

	/* { "description" : "", "verbs":[] }

	Required: true
	*/
	ActualValue float64 `json:"actualValue,omitempty"`

	/* BillingEntity billing entity
	 */
	BillingEntity *string `json:"billingEntity,omitempty"`

	/* { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	 */
	ChangedBy *string `json:"changedBy,omitempty"`

	/* { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	 */
	Created strfmt.DateTime `json:"created,omitempty"`

	/* { "description" : "Refund requested by this account", "verbs":["GET"] }
	 */
	CreatedBy *string `json:"createdBy,omitempty"`

	/* { "description" : "Currency of the refund specified by a three character ISO 4217 currency code.", "verbs":["GET"] }

	Required: true
	*/
	Currency string `json:"currency,omitempty"`

	/* Fields fields
	 */
	Fields map[string]string `json:"fields,omitempty"`

	/* { "description" : "", "verbs":["GET", "PUT"] }
	 */
	ID *string `json:"id,omitempty"`

	/* { "description" : "Invoice to refund.", "verbs":["POST","GET"] }
	 */
	InvoiceID *string `json:"invoiceID,omitempty"`

	/* { "description" : "Invoice payment to refund", "verbs":["POST", "GET"] }
	 */
	InvoicePaymentID *string `json:"invoicePaymentID,omitempty"`

	/* { "description" : "Nominal value refunded.", "verbs":[] }

	Required: true
	*/
	NominalRefundedValue float64 `json:"nominalRefundedValue,omitempty"`

	/* { "description" : "", "verbs":[] }

	Required: true
	*/
	NominalValue float64 `json:"nominalValue,omitempty"`

	/* NotificationObjectGraph notification object graph
	 */
	NotificationObjectGraph *string `json:"notificationObjectGraph,omitempty"`

	/* { "description" : "", "verbs":[] }
	 */
	OrganizationID *string `json:"organizationID,omitempty"`

	/* { "description" : "Reference in the gateway to the payment being refunded.", "verbs":["GET"] }
	 */
	OriginalGatewayPaymentReference *string `json:"originalGatewayPaymentReference,omitempty"`

	/* { "description" : "Original payment being refunded.", "verbs":["GET"] }
	 */
	OriginalPaymentID *string `json:"originalPaymentID,omitempty"`

	/* OriginalReceipt original receipt
	 */
	OriginalReceipt *Receipt `json:"originalReceipt,omitempty"`

	/* { "description" : "ID of the receipt for the successful payment that this entity refunds.", "verbs":["POST","GET"] }
	 */
	OriginalReceiptID *string `json:"originalReceiptID,omitempty"`

	/* { "description" : "Payment method to refund from", "verbs":["GET"] }
	 */
	PaymentMethodID *string `json:"paymentMethodID,omitempty"`

	/* { "description" : "The reason for the refund.", "verbs":["GET"] }
	 */
	Reason *string `json:"reason,omitempty"`

	/* Receipt receipt
	 */
	Receipt *Receipt `json:"receipt,omitempty"`

	/* { "description" : "ID of the receipt for this refund.", "verbs":["POST","GET"] }
	 */
	ReceiptID *string `json:"receiptID,omitempty"`

	/* { "description" : "When the refund was completed", "verbs":["GET"] }
	 */
	RefundCompleted strfmt.DateTime `json:"refundCompleted,omitempty"`

	/* { "description" : "", "verbs":[] }
	 */
	RefundInvoicePaymentID *string `json:"refundInvoicePaymentID,omitempty"`

	/* {"default":"<span class=\"label label-default\">SingleAttempt</span>","description":The mechanism by which credit is returned to the customer:<br><span class=\"label label-default\">Void</span> &mdash; The original authorized payment is voided before capture.<br><span class=\"label label-default\">Refund</span> &mdash; A refund is issued against an already-captured payment.","verbs":["GET"]}

	Required: true
	*/
	RefundNature string `json:"refundNature,omitempty"`

	/* RefundPayment refund payment
	 */
	RefundPayment *Payment `json:"refundPayment,omitempty"`

	/* { "description" : "Identifier for the payment used to refund", "verbs":["GET"] }
	 */
	RefundPaymentID *string `json:"refundPaymentID,omitempty"`

	/* { "default" : "AwaitingRefund", "PUT_description" : "<span class=\"label label-default\">Pending</span> refunds can be set to <span class=\"label label-default\">AwaitingRefund</span> to initiate the refund or <span class=\"label label-default\">Cancelled</span> to stop the refund.", "description" : "Initially a refund is in the <span class=\"label label-default\">AwaitingRefund</span> state. Once the funds are successfully returned the state is <span class=\"label label-default\">Refunded</span>. If the refund fails or is rejected is it set as <span class=\"label label-default\">Failed</span>. Refunds can be set to a <span class=\"label label-default\">Pending</span> state to support authorization flows, and will leave the refund pending until updated to <span class=\"label label-default\">AwaitingRefund</span>. <span class=\"label label-default\">Cancelled</span> is when a refund will not be executed.", "verbs":["GET", "POST", "PUT"] }

	Required: true
	*/
	RefundState string `json:"refundState,omitempty"`

	/* { "description" : "Value refunded", "verbs":["GET"] }
	 */
	Refunded *float64 `json:"refunded,omitempty"`

	/* RefundedValue refunded value
	 */
	RefundedValue *float64 `json:"refundedValue,omitempty"`

	/* Type type
	 */
	Type *string `json:"type,omitempty"`

	/* { "description" : "The UTC DateTime when the object was last updated. ", "verbs":[] }
	 */
	Updated strfmt.DateTime `json:"updated,omitempty"`

	/* { "description" : "Positive decimal representing the total value to refund. This is at most the amount un-refunded on the payment. If amount is the total payment amount is refunded.", "verbs":["POST","GET"] }
	 */
	Value *float64 `json:"value,omitempty"`
}

// Validate validates this refund
func (m *Refund) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActualRefundedValue(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateActualValue(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingEntity(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFields(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNominalRefundedValue(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNominalValue(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRefundNature(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRefundState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Refund) validateActualRefundedValue(formats strfmt.Registry) error {

	if err := validate.Required("actualRefundedValue", "body", float64(m.ActualRefundedValue)); err != nil {
		return err
	}

	return nil
}

func (m *Refund) validateActualValue(formats strfmt.Registry) error {

	if err := validate.Required("actualValue", "body", float64(m.ActualValue)); err != nil {
		return err
	}

	return nil
}

var refundBillingEntityEnum []interface{}

func (m *Refund) validateBillingEntityEnum(path, location string, value string) error {
	if refundBillingEntityEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Notification","Organization","OrganizationGateway","Product","User","Subscription","Profile","ProductRatePlan","Client","Invoice","PricingComponentValue","Account","PricingComponentValueChange","PricingComponentTier","PricingComponent","PricingCalculation","CouponDefinition","CouponInstance","CouponModifier","CouponRule","CouponBookDefinition","CouponBook","InvoiceLine","Webhook","SubscriptionCancellation","NotificationSnapshot","InvoicePayment","InvoiceLinePayment","Payment","PaymentMethod","PaymentMethodSubscriptionLink","DunningLine","CybersourceToken","Card","Alias","PaypalSimplePaymentReconciliation","FreePaymentReconciliation","LocustworldPaymentReconciliation","CouponInstanceExistingValue","TaxLine","TaxationStrategy","TaxationLink","Address","AmendmentPriceNTime","Authority","UnitOfMeasure","SearchResult","Amendment","AuditLog","Password","Username","FixedTermDefinition","FixedTerm","Refund","CreditNote","Receipt","AmendmentCompoundConstituent","APIConfiguration","StripeToken","BraintreeToken","BalancedToken","PaypalToken","AuthorizeNetToken","SpreedlyToken","GatewayRevenue","AmendmentDiscardAmendment","CancellationAmendment","CompoundAmendment","CompoundAmendmentConstituent","FixedTermExpiryAmendment","InvoiceNextExecutionAttemptAmendment","PricingComponentValueAmendment","BraintreeMerchantAccount","WebhookSubscription","Migration","CassResult","CassPaymentResult","CassProductRatePlanResult","CassChurnResult","CassUpgradeResult","SubscriptionCharge","CassPaymentPProductResult","ProductPaymentsArgs","StripeACHToken","UsageAmount","UsageSession","Usage","UsagePeriod","Period","OfflinePayment","CreditNotePayment","CardVaultPayment","FreePayment","BraintreePayment","BalancedPayment","CybersourcePayment","PaypalPayment","PaypalSimplePayment","LocustWorldPayment","StripeOnlyPayment","ProductPaymentsResult","StripeACHPayment","AuthorizeNetPayment","CompoundUsageSession","CompoundUsage","UsageRoundingStrategies","BillforwardManagedPaymentsResult","PricingComponentValueMigrationChargeAmendmentMapping","SubscriptionLTVResult","AccountLTVResult","ProductRatePlanPaymentsResult","DebtsResult","AccountPaymentsResult","ComponentChange","QuoteRequest","Quote","CouponCharge","CouponInstanceInvoiceLink","Coupon","CouponDiscount","CouponUniqueCodesRequest","CouponUniqueCodesResponse","GetCouponsResponse","AddCouponCodeRequest","AddCouponCodeResponse","RemoveCouponFromSubscriptionRequest","TokenizationPreAuth","StripeTokenizationPreAuth","BraintreeTokenizationPreAuth","SpreedlyTokenizationPreAuth","SagePayTokenizationPreAuth","PayVisionTokenizationPreAuth","TokenizationPreAuthRequest","AuthCaptureRequest","StripeACHBankAccountVerification","PasswordReset","PricingRequest","AddTaxationStrategyRequest","AddPaymentMethodRequest","APIRequest","SagePayToken","SagePayNotificationRequest","SagePayNotificationResponse","SagePayOutstandingTransaction","SagePayEnabledCardType","TrustCommerceToken","SagePayTransaction","PricingComponentValueResponse","MigrationResponse","TimeResponse","EntityTime","Email","AggregationLink","BFPermission","Role","PermissionLink","PayVisionToken","PayVisionTransaction","KashToken","EmailProvider","DataSynchronizationJob","DataSynchronizationJobError","DataSynchronizationConfiguration","DataSynchronizationAppConfiguration","AggregationChildrenResponse","MetadataKeyValue","Metadata","AggregatingComponent","PricingComponentMigrationValue","InvoiceRecalculationAmendment","IssueInvoiceAmendment","EmailSubscription","RevenueAttribution"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			refundBillingEntityEnum = append(refundBillingEntityEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, refundBillingEntityEnum); err != nil {
		return err
	}
	return nil
}

func (m *Refund) validateBillingEntity(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingEntity) { // not required
		return nil
	}

	if err := m.validateBillingEntityEnum("billingEntity", "body", *m.BillingEntity); err != nil {
		return err
	}

	return nil
}

func (m *Refund) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", string(m.Currency)); err != nil {
		return err
	}

	return nil
}

func (m *Refund) validateFields(formats strfmt.Registry) error {

	if swag.IsZero(m.Fields) { // not required
		return nil
	}

	if err := validate.Required("fields", "body", m.Fields); err != nil {
		return err
	}

	return nil
}

func (m *Refund) validateNominalRefundedValue(formats strfmt.Registry) error {

	if err := validate.Required("nominalRefundedValue", "body", float64(m.NominalRefundedValue)); err != nil {
		return err
	}

	return nil
}

func (m *Refund) validateNominalValue(formats strfmt.Registry) error {

	if err := validate.Required("nominalValue", "body", float64(m.NominalValue)); err != nil {
		return err
	}

	return nil
}

var refundRefundNatureEnum []interface{}

func (m *Refund) validateRefundNatureEnum(path, location string, value string) error {
	if refundRefundNatureEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Refund","Void"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			refundRefundNatureEnum = append(refundRefundNatureEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, refundRefundNatureEnum); err != nil {
		return err
	}
	return nil
}

func (m *Refund) validateRefundNature(formats strfmt.Registry) error {

	if err := validate.Required("refundNature", "body", string(m.RefundNature)); err != nil {
		return err
	}

	if err := m.validateRefundNatureEnum("refundNature", "body", m.RefundNature); err != nil {
		return err
	}

	return nil
}

var refundRefundStateEnum []interface{}

func (m *Refund) validateRefundStateEnum(path, location string, value string) error {
	if refundRefundStateEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Pending","AwaitingRefund","Refunded","Cancelled","Failed"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			refundRefundStateEnum = append(refundRefundStateEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, refundRefundStateEnum); err != nil {
		return err
	}
	return nil
}

func (m *Refund) validateRefundState(formats strfmt.Registry) error {

	if err := validate.Required("refundState", "body", string(m.RefundState)); err != nil {
		return err
	}

	if err := m.validateRefundStateEnum("refundState", "body", m.RefundState); err != nil {
		return err
	}

	return nil
}

var refundTypeEnum []interface{}

func (m *Refund) validateTypeEnum(path, location string, value string) error {
	if refundTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["InvoicePayment","Payment"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			refundTypeEnum = append(refundTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, refundTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *Refund) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}
