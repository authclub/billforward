package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/strfmt"
)

/*MutableBillingEntity Mutable entities are those entities that can be updated after their initial creation.

swagger:model MutableBillingEntity
*/
type MutableBillingEntity struct {

	/* { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	 */
	ChangedBy *string `json:"changedBy,omitempty"`

	/* This is config id which links to this sync job.

	Required: true
	*/
	ConfigID string `json:"configID,omitempty"`

	/* { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	 */
	Created strfmt.DateTime `json:"created,omitempty"`

	/* The account who created the synch job.
	 */
	CreatedBy *string `json:"createdBy,omitempty"`

	/* UTC DateTime of the start of the data to sync.
	 */
	DataFrom strfmt.DateTime `json:"dataFrom,omitempty"`

	/* UTC DateTime of the start of the data to sync.
	 */
	DataTill strfmt.DateTime `json:"dataTill,omitempty"`

	/* Is the sync job deleted.

	Required: true
	*/
	Deleted bool `json:"deleted,omitempty"`

	/* Description of the Job.

	Required: true
	*/
	Description string `json:"description,omitempty"`

	/* ID of the Synchronization Job.
	 */
	ID *string `json:"id,omitempty"`

	/* The max number of times the records will try to resync.

	Required: true
	*/
	MaxRetryTimes int32 `json:"maxRetryTimes,omitempty"`

	/* Name of the Job.

	Required: true
	*/
	Name string `json:"name,omitempty"`

	/* Organization associated with the refund.

	Required: true
	*/
	OrganizationID string `json:"organizationID,omitempty"`

	/* The number of times the records tried to resync.

	Required: true
	*/
	RetryAttempted int32 `json:"retryAttempted,omitempty"`

	/* The scope of the data synch'd.

	Required: true
	*/
	Scope string `json:"scope,omitempty"`

	/* UTC DateTime of the end of the data to sync.
	 */
	Started strfmt.DateTime `json:"started,omitempty"`

	/* This is the state of job. Pending jobs have not run. Complete jobs have run without error. Failed jobs have one of more errors. Cancelled jobs did not run.

	Required: true
	*/
	State string `json:"state,omitempty"`

	/* UTC DateTime of the start of the data to sync.
	 */
	Stopped strfmt.DateTime `json:"stopped,omitempty"`

	/* This is the target of the job.

	Required: true
	*/
	Target string `json:"target,omitempty"`

	/* This is the type of job. Incremental jobs just sync changes, fully jobs sync all data.

	Required: true
	*/
	Type string `json:"type,omitempty"`

	/* { "description" : "The UTC DateTime when the object was last updated.", "verbs":[] }
	 */
	Updated strfmt.DateTime `json:"updated,omitempty"`
}

// Validate validates this mutable billing entity
func (m *MutableBillingEntity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConfigID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDeleted(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMaxRetryTimes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateOrganizationID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRetryAttempted(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateScope(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTarget(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MutableBillingEntity) validateConfigID(formats strfmt.Registry) error {

	if err := validate.Required("configID", "body", string(m.ConfigID)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateDeleted(formats strfmt.Registry) error {

	if err := validate.Required("deleted", "body", bool(m.Deleted)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", string(m.Description)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateMaxRetryTimes(formats strfmt.Registry) error {

	if err := validate.Required("maxRetryTimes", "body", int32(m.MaxRetryTimes)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateOrganizationID(formats strfmt.Registry) error {

	if err := validate.Required("organizationID", "body", string(m.OrganizationID)); err != nil {
		return err
	}

	return nil
}

func (m *MutableBillingEntity) validateRetryAttempted(formats strfmt.Registry) error {

	if err := validate.Required("retryAttempted", "body", int32(m.RetryAttempted)); err != nil {
		return err
	}

	return nil
}

var mutableBillingEntityScopeEnum []interface{}

func (m *MutableBillingEntity) validateScopeEnum(path, location string, value string) error {
	if mutableBillingEntityScopeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Manual","Scheduled"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			mutableBillingEntityScopeEnum = append(mutableBillingEntityScopeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, mutableBillingEntityScopeEnum); err != nil {
		return err
	}
	return nil
}

func (m *MutableBillingEntity) validateScope(formats strfmt.Registry) error {

	if err := validate.Required("scope", "body", string(m.Scope)); err != nil {
		return err
	}

	if err := m.validateScopeEnum("scope", "body", m.Scope); err != nil {
		return err
	}

	return nil
}

var mutableBillingEntityStateEnum []interface{}

func (m *MutableBillingEntity) validateStateEnum(path, location string, value string) error {
	if mutableBillingEntityStateEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Pending","Complete","Failed","Cancelled","Processing"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			mutableBillingEntityStateEnum = append(mutableBillingEntityStateEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, mutableBillingEntityStateEnum); err != nil {
		return err
	}
	return nil
}

func (m *MutableBillingEntity) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", string(m.State)); err != nil {
		return err
	}

	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var mutableBillingEntityTargetEnum []interface{}

func (m *MutableBillingEntity) validateTargetEnum(path, location string, value string) error {
	if mutableBillingEntityTargetEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Salesforce"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			mutableBillingEntityTargetEnum = append(mutableBillingEntityTargetEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, mutableBillingEntityTargetEnum); err != nil {
		return err
	}
	return nil
}

func (m *MutableBillingEntity) validateTarget(formats strfmt.Registry) error {

	if err := validate.Required("target", "body", string(m.Target)); err != nil {
		return err
	}

	if err := m.validateTargetEnum("target", "body", m.Target); err != nil {
		return err
	}

	return nil
}

var mutableBillingEntityTypeEnum []interface{}

func (m *MutableBillingEntity) validateTypeEnum(path, location string, value string) error {
	if mutableBillingEntityTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Incremental","Full"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			mutableBillingEntityTypeEnum = append(mutableBillingEntityTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, mutableBillingEntityTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *MutableBillingEntity) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", string(m.Type)); err != nil {
		return err
	}

	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}
